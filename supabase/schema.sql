-- Create Profiles Table
create table public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  nickname text unique,
  full_name text,
  phone text,
  show_phone boolean default false,
  county text,
  municipality text,
  city text,
  is_dealer boolean default false,
  avatar_url text,
  updated_at timestamp with time zone default timezone('utc'::text, now())
);

-- Enable RLS
alter table public.profiles enable row level security;

-- Policies
create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update their own profile."
  on profiles for update
  using ( auth.uid() = id );

-- Create Ads Table
create table public.ads (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) not null,
  title text not null,
  description text,
  price integer not null,
  brand text not null,
  model text not null,
  year integer not null,
  miles integer not null,
  fuel text not null,
  gearbox text not null,
  body_type text,
  color text,
  location text not null,
  image_color text, -- Temporary until real images
  images text[],
  created_at timestamp with time zone default timezone('utc'::text, now()),
  expires_at timestamp with time zone default timezone('utc'::text, now() + interval '3 months')
);

-- Ads RLS
alter table public.ads enable row level security;

create policy "Ads are viewable by everyone."
  on ads for select
  using ( true );

create policy "Users can insert their own ads."
  on ads for insert
  with check ( auth.uid() = user_id );

create policy "Users can update their own ads."
  on ads for update
  using ( auth.uid() = user_id );

create policy "Users can delete their own ads."
  on ads for delete
  using ( auth.uid() = user_id );

-- Handle User Creation (Trigger)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, avatar_url)
  values (new.id, new.email, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- STORAGE: Create 'car-images' bucket
insert into storage.buckets (id, name, public) 
values ('car-images', 'car-images', true)
on conflict (id) do nothing;

-- STORAGE POLICIES
-- Allow public access to view images
create policy "Public Access"
on storage.objects
for select
using ( bucket_id = 'car-images' );

-- Allow authenticated users to upload images
create policy "Authenticated Upload"
on storage.objects
for insert
with check ( bucket_id = 'car-images' and auth.role() = 'authenticated' );

-- Allow users to update their own images (optional, but good for cleanup/replacements)
create policy "User Update Own Images"
on storage.objects
for update
using ( bucket_id = 'car-images' and auth.uid() = owner );

-- Allow users to delete their own images
create policy "User Delete Own Images"
on storage.objects
for delete
using ( bucket_id = 'car-images' and auth.uid() = owner );
